Recommended to learn before Node.js
===================================
Variables
Scopes
Functions
Arrow Function
this operator
Loops
Arrays
fetch()
ES-6 and beyond 
(class,module,rest,spread,collections,promise,async await,Enhanced Object Literals)



Node.js Syllabus
================
-Node.JS - Introduction, Advantages
-Traditional Web Server Model, Node.js Process Model
-Local Environment SetUp
-Node.js Console - REPL
-NPM , NPX
-Modules: Core, Local , 3rd party
-Global Objects
-CallBacks, Generators
-File System
-Debugging Node JS Application
-Buffer & Streams
-Events (Event Loop,Event Emitter)
-Creating web server & Handling http requests (HTTP)
-Express Framework-routes
-MongoDB
-Database connectivity 
-Mongoose,graphQL
-Template Engines (Jade/Pug, vash, EJS, handlebars)
-Redis (Caching)
-Swagger  (API Documentation)
-Unit testing


Projects
========
-NodeEmailer (Send Email)
-Chat Application (Socket.io)
-Express Validator 
-Image Upload (express-file-uploader)
-Image Upload (Formidable)
-JWT Token
-End To End Application





What NodeJs is?
===============
-Opensource and cross-platform JavaScript runtime environment.
-Allows to run JavaScript on the server(outside the browser).
-Built on Google Chrome's JavaScript V8 Engine. 
-Single threaded, non-blocking, and event-driven execution model.
-It is used to develop I/O intensive web applications. 
-ex:video streaming sites, real-time chat application, Game servers and web applications.
-It's not the best choice for CPU intensive work.(Complex calculations)


	Browser					 Node.js
======================================================
-DOM (document)				-No DOM
-Window						-No Window (global)
-Cookies					-No Cookies
-Offline Storage            -No Offline Storage
-No FileSystem				-FileSystem
-Database Interaction(No)	-Database Interaction(yes)
-Client Apps				-Server side Apps



Key Features of Node.js
=======================
Asynchronous and Event Driven:
	All APIs of Node Js are asynchronous. 
	This feature means that if  Node receives a request for some Input/Output operation, it will execute that operation in the background and continue with the processing of other requests. 
	Thus it will not wait for the response from the previous requests.
It's very fast:
	Node Js uses the V8 JavaScript Runtime engine, the one which is used by Google Chrome. 
	Node has a wrapper over the JavaScript engine which makes the runtime engine much faster and hence processing of requests in NodeJS is faster.
Single Threaded but Highly Scalable:
	Node Js uses a single thread model for event looping. 
	The response from these events may or may not reach the server immediately. 
	However, this does not block other operations. 
	Thus making Node.js highly scalable. 
	Traditional servers create limited threads to handle requests while Node.js creates	a single thread that provides service to much larger numbers of such requests.
Node js library uses JavaScript:
	The majority of developers are already well-versed in JavaScript. 
	Hence, development in Node.js becomes easier for a developer who knows JavaScript.
Community –
	There is an Active and vibrant community for the Node Js framework - The active community always keeps the framework updated with the latest trends in the web development.
No Buffering –
	Node js applications never buffer any data. 
	They simply output the data in chunks.
NPM (Node Package Manager)–
	it comes with node js & allows us to install various Packages for Node js Application. (lodash,cors,axios,express)



V8 JavaScript Engine
====================
-V8 is the name of the JavaScript engine that powers Google Chrome.
-V8 takes our JavaScript and executes it while browsing with Chrome.
-V8 is written in C++, and it's continuously improved.
-JavaScript is generally considered an interpreted language, but modern JavaScript engines no longer just interpret JavaScript, they compile it.
-JavaScript is internally compiled by V8 with 

JS Code -->




What Can Node.js Do?
====================
-Node.js can generate dynamic page content.
-Node.js can create, open, read, write, delete, and close files on the server.
-Node.js can collect form data.
-Node.js can add, delete, modify data in the database.



How NodeJs works/NodeJs Process Model
=====================================
-In the traditional web server model, each request is handled by a dedicated thread from the thread pool.
If no thread is available in the thread pool at any point of time then the request waits till the next available thread. 
-Dedicated thread executes a particular request and does not return to thread pool until it completes the execution and returns a response.

-All the user requests will be handled by a single thread and all the I/O work or long running job is performed asynchronously for a particular request. 
this single thread doesn't have to wait for the request to complete and is free to handle the next request. 
-When asynchronous I/O work completes then it processes the request further and sends the response.
-An event loop is constantly watching for the events to be raised for an asynchronous job and executing callback function when the job completes. 
-Internally, Node.js uses libev for the event loop which in turn uses internal C++ thread pool to provide asynchronous I/O.



1. Clients send HTTP requests to NodeJS server.
2. Event-Loop(Single Thread) delegates long-running operations to non-blocking workers and becomes available to handle the next request.
3. When asynchronous I/O work completes, EventLoop processes the request further and sends the response to the client.
https://www.dotnettricks.com/learn/nodejs/exploring-nodejs-code-execution-process

UV_THREADPOOL_SIZE=size


NodeJs vs Others
================
-A common task for a web server can be to open a file on the server and return the content to the client.

Here is how PHP or ASP handles a file request:
	1. Sends the task to the computer's file system.
	2. Waits while the file system opens and reads the file.
	3. Returns the content to the client.
	4. Ready to handle the next request.
Here is how Node.js handles a file request:
	1. Sends the task to the computer's file system.
	2. Ready to handle the next request.
	3. When the file system has opened and read the file, the server returns the content to the client.
-Node.js eliminates the waiting, and simply continues with the next request.
-Node.js runs single-threaded, non-blocking, asynchronously programming, which is very memory efficient.



Blocking vs Non-Blocking I/O
============================
-waiter takes the order and gives it to chef.
 while the chef is preparing that order, 
 waiter will take new orders and will give it back to the chef.
 waiter doesn't wait for the chef to prepare the food.
-Blocking is when the execution of additional JavaScript in the Node.js process must wait until a non-JavaScript operation completes. 
-This happens because the event loop is unable to continue running JavaScript while a blocking operation is occurring.
-Blocking call waits for the I/O operation to complete before returning. 
 Its results are returned synchronously. 
 Nothing else in that process takes place during the waiting. 
-non-blocking call returns immediately without results and uses alternate means to check for completion. 
 Other processing can be done while waiting and the results are returned asynchronously. 
-Node.js libraries and core api provide non-blocking calls that can be used to build performant applications. Such applications make use of I/O waiting time to serve other requests
-concurrency refers to the event loop's capacity to execute JavaScript callback functions after completing other work
-let's consider a case where each request to a web server takes 50ms to complete and 45ms of that 50ms is database I/O that can be done asynchronously. Choosing non-blocking asynchronous operations frees up that 45ms per request to handle other requests. This is a significant difference in capacity just by choosing to use non-blocking methods instead of blocking methods


Q. What is Reactor Pattern in Node.js?




How to install Node.js
======================
-Official packages for all the major platforms are available in the below URL
 https://nodejs.dev/en/download/
-nvm is a popular way to run Node.js. It allows to easily switch the Node.js version.
  NVM for Mac - https://tecadmin.net/install-nvm-macos-with-homebrew/
  NVM for windows - https://github.com/coreybutler/nvm-windows

NVM useful commands
-------------------
`nvm  --version` to check version 
`nvm list` to list all the available nvm versions
`nvm use 15.0` to use a specific version of nodejs
`nvm install 15.0` to install a specific version of nodejs




REPL
====
-REPL stands for Read-Eval-Print-Loop.
 R - Reads user's input
 E - Evaluates the expression
 P - Prints the result
 L - Loops the above things until user kills the process
-Node.js comes with virtual environment called REPL.
-it is similar to Shell in Linux or command prompt in windows where 
 a command is entered and the system responds with an output in an interactive mode
-It is a quick and easy way to test simple Node.js/JavaScript code.
-To launch the REPL (Node shell), open command prompt and type 'node'.
-If you need to write multi line JavaScript expression or function then just press Enter.
 (The REPL terminal will display three dots (...), it means you can continue on next line)
-We can execute an external JavaScript file by writing 'Node Filename'.
-assign the result of the most recently evaluated expression to the special variable _ (underscore)
	 a = 10; b = 20; a+b;
	 sum = _; console.log(sum);
-To Open REPL in editor mode , use .editor
-To Exit REPL type .exit
-if you press the tab key the REPL will try to autocomplete what you wrote to match a variable you already defined or a predefined one.
-Exploring JavaScript objects ( os, fs , http)



REPL Command		Description
--------------------------------
.help				Display help on all the commands
.editor			    enables editor mode, to write multiline JavaScript code with ease. Once you are in this mode, enter ctrl-D to run the code you wrote
tab Keys			Display the list of all commands.
Up/Down Keys		See previous commands applied in REPL.
.save filename		Save current Node REPL session to a file.
.load filename		Load the specified file in the current Node REPL session.
.exit				exits the repl (same as pressing ctrl-C two times)
ctrl + c			Terminate the current command.
ctrl + c (twice)	Exit from the REPL.
ctrl + d			Exit from the REPL.
.break				Exit from multiline expression.
.clear				Exit from multiline expression.(Alias for .break)



accept arguments from the command line
======================================
-we can pass any number of arguments while invoking a Node.js application.
-Arguments can be standalone or have a key and a value.
 ex: node app.js sanjay
     node app.js name=sanjay
-arguments can be collected by using 'process' module's argv property which is an array.
-The first element is the full path of the node command.
-The second element is the full path of the file being executed.
-All the additional arguments are present from the third position going forward.
-we can iterate over all the arguments (including the node path and the file path) using a loop:
	process.argv.forEach((val, ind) => {
	  console.log(`index ${ind} argument -> ${val}`);
	})
-we can get only the additional arguments by creating a new array that excludes the first 2 params
 const args = process.argv.slice(2)
-The best way to deal with key:value arguements is by using the minimist library.
 const args = require('minimist')(process.argv.slice(2))
 console.log(args['name'])
-use double dashes before each argument name
 node app.js --name=sanjay

Assignment: Create 1 Arithmetic example using command Line Arg


How to exit from a Node.js shell
================================
There are various ways to terminate a Node.js application.
-Press Ctrl + C twice.
-Press Ctrl + D once.
-type .exit and press Enter
-process.exit()
-process.kill(process.pid)

Note: process module does not need a "require", it's automatically available.





Visual Studio Code
==================
vscode-icons
prettier
tab nine
thunderclient
ESLint


Browser extensions
==================
-json viewer 
-POSTMAN
-Allow CORS



Debug NodeJs Code
=================	
1. Debugging natively
  a. node debug/inspect your-script.js  (type next, help)
     https://nodejs.dev/en/api/v19/debugger/
  b. use debugger;  in a code line you want
  
cont, c               Resume execution
next, n               Continue to next line in current file
step, s               Step into, potentially entering a function
out, o                Step out, leaving the current function
backtrace, bt         Print the current backtrace
  
  
2. visual Studio Code
   In the Debug panel, click the settings icon to open .vscode/launch.json.
   Select "Node.js" for initial setup.






NPM (Node Package Manager)
==========================
-npm is the standard package manager for Node.js.
-Node Package Manager (NPM) provides two main functionalities:
	1.Online repositories for node.js packages/
	which are searchable on https://www.npmjs.com/
	2.Command line utility to install Node.js packages, do version management and dependency management of Node.js packages.
	
-NPM comes bundled with Node.js installables.
-To verify npm version, Run the below command  
 npm --version/-v
 
-initialize a nodejs project
 npm init
 npm init -y (everything default)
 
-npm install 
 install all the modules as specified in package.json

-Install a Module using npm
 npm install <Module Name>
 
-Install the package globally
 npm install <package_name> -g
 
-Save the package as dependency
 npm install <package_name> --save
 
-Save the package as dev-dependency
 npm install <package_name> --save-dev
 
-Install the latest version of a package
 npm install <package_name>@latest
 
-Install any particluar version of a package
 npm install <package_name>@<version_number>
 npm install bootstrap@4.0.1
 
-Uninstalling Packages/Modules via NPM
 npm uninstall <package_name>
 
-Update Packages/Modules via NPM
 npm update <package_name>
 
-Searching a particular package
 npm search <package_name>
 
-List all Installed Packages Locally
 npm list/ls

-List all Installed Packages Globally
 npm ls -g
 
-Run a Script
 npm run <script-name>


npm i nodemon 			 	--> helps during development and production dependencies
npm i nodemon --save  		--> helps during development and production dependencies
npm i nodemon --save-dev  	--> helps during development not in production(-D)
npm i nodemon --no-save 	--> installs but does not add the entry to the package.json file dependencies
npm i nodemon --save-optional --> installs and adds the entry to the package.json file optionalDependencies
npm i --no-optional  --> will prevent optional dependencies from being installed





NPM Global vs Local Installation
--------------------------------
-By default, NPM installs any dependency in the local mode. 
-Local mode refers to the package installation in node_modules directory lying in the folder where Node application is present. 
-Locally deployed packages are accessible via require() method. 
 ex: npm i express
-Run the below command command to list down all the locally installed modules. 
 npm ls
-Globally installed packages/dependencies are stored in system directory. 
-Such dependencies can be used in CLI (Command Line Interface) function of any node.js but cannot be imported using require() in Node application directly. 
 ex:- npm i express -g
-few packages that should be gloabbllay installed: 
 1.npm   2.nodemon  3.typescript 4.create-react-app 5.angular-cli 6.json-server
-few packages that should be locally installed:
 1.minimist  2.express  3.lodash  4.bootstrap  5.axios  6.rxjs
 
If you’re installing something that you want to use in your program, using require('whatever'), then install it locally, at the root of your project.
If you’re installing something that you want to use in your shell, on the command line or something, install it globally, so that its binaries end up in your PATH environment variable.

 
 
Package.json
============
-Contains the metadata of the project.
-Helps NPM to understand how the project should be handled along with its dependencies.
-package.json files contain the below information.
	  project name,
	  version,
	  homepage,
	  description,
	  author,
	  keywords 
	  scripts etc.
-package.json file is normally located at the root directory of a Node.js project.


package.json  VS  package-lock.json
===================================
-Package.json is mandatory and package-lock.json is optional.
-package.json is a file that contains information about your project (name, version, scripts) and it lists the packages that your project is dependent on.

package-lock.json avoids installing updated minor/hotfix version when someone clones your repo and run npm install in their machine.

-The goal of package-lock.json file is to keep track of the exact version of every package that is installed so that a product is 100% reproducible in the same way even if packages are updated by their maintainers.

-in package.json (~) tells go up to hot-fixes 1.4.X if 1.4.1 is installed
 in package.json (^) checks if there is a newer version under 1.x.x if 1.4.1 is installed
 in package-lock.json - there is neither ~ nor ^




NPX
===
NPX : Node Package Executer (used to execute Node.js packages)
-executes Node.js commands without installing them.
-When you install NPM version 5.2.0 or higher, get NPX installed
-we can install npx using the below comand
 npm i -g npx
-npx helps us avoid versioning, dependency issues and installing unnecessary packages that we just want to try out.
-provides a clear and easy way of executing packages, commands, modules and even GitHub gists and repositories.
-ex:npx create-react-app my-sample-react-app



Nodemon
=======
-Nodemon is a utility that will monitor for any changes in your source and automatically restart your server.
-Nodemon can be installed using NPM.
 ex:- npm i -g nodemon
-Check if Nodemon is installed?
 nodemon -v
-Just use nodemon instead of node to run your code, your process will automatically restart when your code changes
 ex:- nodemon file1.js
-the 'node_modules' folder is ignored by default.
-You can restart the process at any time by typing rs and hitting enter.


Nodemon Features:
----------------
-Automatic restarting of application.
-Detects default file extension to monitor.
-Default support for node & coffeescript, but easy to run any executable (such as python, make, etc).
-Ignoring specific files or directories.
-Watch specific directories.
-Works with server applications or one time run utilities and REPLs.
-Requirable in node apps.
-Open source and available on github.
 

Node.js Global Objects
======================
-Node.js global objects are global in nature and available in all modules.
-we dont have to include these objects in our application; they can be directly used.
-A list of Node.js global objects are given below:
	_ _dirname
	_ _filename
	console - log(),error(),warn(),time(),timeEnd(),trace(),dir()
	process - exit(),beforeExit(), uncaughtException()
	buffer
	setImmediate(callback[, arg][, ...])
	setInterval(callback, delay[, arg][, ...])
	setTimeout(callback, delay[, arg][, ...])
	clearImmediate(immediateObject)
	clearInterval(intervalObject)
	clearTimeout(timeoutObject)
	export
	require
	fetch
	global


setImmediate() vs setTimeout()
==============================
-setImmediate() is designed to execute a script once the current poll phase completes.
-setTimeout() schedules a script to be run after a minimum threshold in ms has elapsed.
-setImmediate callbacks are called after I/O Queue callbacks are finished or timed out. setImmediate callbacks are placed in Check Queue, which are processed after I/O Queue.
-setTimeout(fn, 0) callbacks are placed in Timer Queue and will be called after I/O callbacks as well as Check Queue callbacks. As event loop, process the timer queue first in each iteration, so which one will be executed first depends on which phase event loop is.

-if we run setImmediate() & setTimeout() which is not within an I/O cycle (i.e. the main module), the order in which the two timers are executed is non-deterministic.
-However, if you move the two calls within an I/O cycle, the immediate callback is always executed first.



Symbol 
======
-A 'symbol' represents a unique identifier.
-Symbols are often used to add unique property keys to an object that won’t collide with keys.
-create a symbol by calling the Symbol(), not by using new keyword.
 let sym1 = Symbol()  // correct
 let sym2 = new Symbol()  // TypeError
-Even if we create many symbols with the same description, they are different values.
 Symbol('foo') === Symbol('foo')  // false
-Symbols allow us to create “hidden” properties of an object, 
 that no other part of code can accidentally access or overwrite.
-If we want to use a symbol in an object literal,we need square brackets around it.
 let id = Symbol();
 let user = {name:'sanjay',[id]:123}
-Symbols are not enumerated,Symbols are skipped by for…in while we iterate object properties.
-Symbols are not part of the Object.keys() or Object.getOwnPropertyNames()
-Symbols assigned to an object can be accessed using the Object.getOwnPropertySymbols() method
-Object.assign() copies both string and symbol properties.



This
====
-this is determined when a function is called. Not when a function is created.
-In the top-level code in a Node module, this is equivalent to module.exports. That's the empty object.
ex: console.log(this, this === module.exports); //true
-When a function is called as a property of an object the value of this will be the object it is called with.
ex: obj.f1(); // this = obj
-in strictmode this value inside a function is undefined.





NodeJs Modules
==============
-A way of encapsulating code in to separate logical units.
-Module:A set of functions you want to include in your application.
-In the Node.js module system, each file is treated as a separate module.
-Node.js includes three types of modules:
	1. Core(Built-in) Modules     	(os,http,fs,path,url)
	2. Local(Custom) Modules    	(created locally in our application)
	3. Third Party(External) Modules  (can be downloaded using NPM. ex:-minimist,express,mongoose,lodash)


Core Modules:
-------------
os-Get OS information
fs-work with the file system
path-handles path elegantly
url-url module includes methods for URL resolution and parsing.
querystring-querystring module includes methods to deal with query string.
http-launch a server,send requests
https-launch a SSL server
events-working with events
util-util module includes utility functions useful for programmers.



Local(Custom) Modules 
=====================
-Node.js has two types of modules: 
	1. ES modules 
	2. CommonJS modules
-By default, Node.js treats JavaScript as CommonJS modules. But we can tell Node.js to treat JavaScript code as ES modules.
-Node.js will treat the following files as ES modules:
	a.Files ending in .mjs
	b.Files ending in .js when the nearest parent package.json file contains a top-level field "type" with a value of "module".



External Modules(minimist,chalk,validator,lodash,moment)
----------------
1. Installing an npm Module
   npm install validator
2. Importing an npm Module
   const validator = require('validator')
   console.log(validator.isURL('https://www.google.co.in/')) // true
   console.log(validator.isEmail('abc@gmail.com')) // true



Node.js OS Module
=================
-The OS module provides information about the computer's operating system.
-while downloading gitbash,mongoDB,postman(OS is auto-populated)

arch()	      Returns the operating system CPU architecture-32/64
constants	 Returns an object containing the operating system's constants for process signals, error cotes etc.
cpus()	       Returns an array containing information about the computer's CPUs
endianness()	Returns the endianness of the CPU
EOL	Returns the end-of-line marker for the current operating system
freemem()	Returns the number of free memory of the system
hostname()	Returns the hostname of the operating system
loadavg()	Returns an array containing the load averages, (1, 5, and 15 minutes)
networkInterfaces()	Returns the network interfaces that has a network address
platform()	Returns information about the operating system's platform
release()	Returns information about the operating system's release
tmpdir()	Returns the operating system's default directory for temporary files
totalmem()	Returns the number of total memory of the system
type()	    Returns the name of the operating system
uptime()	Returns the uptime of the operating system, in seconds
userInfo()	Returns information about the current user




CallBacks
=========
-Callback is an asynchronous equivalent for a function. 
-A callback function is called at the completion of a given task. 
-All the APIs of Node are written in such a way that they support callbacks.


Node.js URL Module
==================
-The URL module splits up a web address into readable parts.
-Parse an address with the url.parse() method, and it will return a URL object with each part of the address as properties.




Node.js fs module
=================
-The fs module provides a lot of very useful functionality to access and interact with the file system.
-There is no need to install it. Being part of the Node.js core, it can be used by simply requiring it. and have access to all its methods.

ex: const fs = require('fs');
fs.access(): check if the file exists and Node.js can access it with its permissions
fs.appendFile(): append data to a file. If the file does not exist, it's created
fs.chmod(): change the permissions of a file specified by the filename passed. Related: fs.lchmod(), fs.fchmod()
fs.chown(): change the owner and group of a file specified by the filename passed. Related: fs.fchown(), fs.lchown()
fs.close(): close a file descriptor
fs.copyFile(): copies a file
fs.createReadStream(): create a readable file stream
fs.createWriteStream(): create a writable file stream
fs.link(): create a new hard link to a file
fs.mkdir(): create a new folder
fs.mkdtemp(): create a temporary directory
fs.open(): opens the file and returns a file descriptor to allow file manipulation
fs.readdir(): read the contents of a directory
fs.readFile(): read the content of a file. Related: fs.read()
fs.readlink(): read the value of a symbolic link
fs.realpath(): resolve relative file path pointers (., ..) to the full path
fs.rename(): rename a file or folder
fs.rmdir(): remove a folder
fs.stat(): returns the status of the file identified by the filename passed. Related: fs.fstat(), fs.lstat()
fs.symlink(): create a new symbolic link to a file
fs.truncate(): truncate to the specified length the file identified by the filename passed. Related: fs.ftruncate()
fs.unlink(): remove a file or a symbolic link
fs.unwatchFile(): stop watching for changes on a file
fs.utimes(): change the timestamp of the file identified by the filename passed. Related: fs.futimes()
fs.watchFile(): start watching for changes on a file. Related: fs.watch()
fs.writeFile(): write data to a file. Related: fs.write()


file encoding
=============
-Both fs.readFileSync() and fs.readFile() take an optional argument encoding. 
-while reading a file, a string will be returned if character encoding is specified.
-while reading a file, a buffer will be returned if character encoding is not specified.
ex: bufferData = fs.readFileSync("./customer.json");
	stringData = fs.readFileSync("./customer.json", "utf8");




JSON
====
-Node has some built in utilities that make it easy to read and write JSON files.
-The simplest way to read a JSON file is to require it. 
 ex: const config = require("./config.json");
-But reading JSON files with require has its downsides. 
-The file will only be read once; requiring it again returns the cached data from the first time require was run. 
-This is fine for loading static data on startup (like config data). But for reading a file that changes on disk, we need to manually read the file using fs.readFile()
  const jsonString = fs.readFileSync("./customer.json");
  const customer = JSON.parse(jsonString);
  
  
  
  

FS Module Error Handling
========================
-No Error tracking : appendFile(), writeFile()
-default error tracking : readFile()
-manual error tracking : unlink(),rename()



What is an error-first callback?
---------------------------------
in NodeJS The first argument is always an error object that the programmer has to check if something went wrong.



Node.js Path Module
===================
-The Path module provides a way of working with directories and file paths.
basename()	Returns the last part of a path
delimiter	Returns the delimiter specified for the platform
dirname()	Returns the directories of a path
extname()	Returns the file extension of a path
format()	Formats a path object into a path string
isAbsolute()	Returns true if a path is an absolute path, otherwise false
join()	Joins the specified paths into one
normalize()	normalizes the given path, resolving '..' and '.' segments.
parse()	Formats a path string into a path object
relative()	Returns the relative path from one specified path to another specified path
resolve()	Resolves the specified paths into an absolute path
sep	Returns the segment separator specified for the platform
win32	Returns an object containing Windows specific properties and methods
posix	Returns an object containing POSIX specific properties and methods


Q. why you’d use the path.join() function instead of using string concatenation??
ans: 1. Supports separators (\ or /) for different OS.
	 2. handles leading and trailing slashes.
	    path.join('data', 'test.txt'); // 'data/test.txt'
		path.join('data', '/test.txt'); // 'data/test.txt'
		path.join('data/', 'test.txt'); // 'data/test.txt'
		path.join('data/', '/test.txt'); // 'data/test.txt'


join() vs resolve()
===================
-join() concatenates(joins) the path segments.
-resolve() creates an absolute path from the root. 
-Both methods will normalize the paths i.e. they treat .. as we normally use them when navigating in the folder structure.
-join() concatenates the the path fragments.
-resolve() looks for the first segment with / from the right and append everything up to this point to the root.





Process Module
==============
-The process core module of Node.js provides the env property which hosts all the environment variables that were set at the moment the process was started.
-Note: process does not require a "require", it's automatically available.
-If you have multiple environment variables in your node project, you can also create an .env file in the root directory of your project, and then use the dotenv package to load them during runtime.
.env file
	USER_ID="239482"
	USER_KEY="abcd"
	NODE_ENV="development"
	PORT=1234
-npm install dotenv
 require('dotenv').config();
	process.env.USER_ID; // "239482"
	process.env.USER_KEY; // "abcd"
	process.env.NODE_ENV; // "development"
-How to find which version of V8 ships with a particular version of Node.js?
	node -p process.versions.v8
-process.nextTick() : invoke this function at the end of the current operation, before the  next event loop tick starts
-Every time the event loop takes a full trip, we call it a tick.
-setTimeout(() => {}, 0) will execute the function at the end of next tick, much later than when using nextTick() which prioritizes the call and executes it just before the beginning of the next tick
 


Child Processes Module
======================
-Node.js allows single-threaded, non-blocking but running a single thread in a CPU cannot handle increasing workload.
-The child_process module can be used to start child processes, and those child processes can easily communicate with each other with a messaging system.
-There are four different ways to create a child process in Node:
	1. exec() 
	2. execFile()
	3. spawn()
	4. fork()
exec() : creates a new shell process and executes a command in that shell.
         The output of the command can be collected via a callback function passed to exec()
execFile() : execute a file (bat/sh)
spawn(): when the command we want to run can output a large amount of data
fork() : 
 
 
 
HTTP Module
===========
-The HTTP module can create an HTTP server.
-receives the request from client & gives a response back to the client.
-Get headers, URL, method and body data from request objects.
-Make routing decisions based on URL and/or other data in request objects.
-Send headers, HTTP status codes and body data via response objects.

createServer()   		Returns a new instance of Server.
listen(PORT,CallBack)   Binds the server to listen on a specific port
close()					Stops the server from listening to more requests

response.writeHead() should be called first when initiating a response, allows 	us to set up the HTTP response code and headers we are sending back.

response.write(chunk[, encoding][, callback]) allows us to send a chunk of data as part of our response.

response.end() signalizes the response as complete, MUST be called once per response.


HTTP Methods
============
https://testfully.io/blog/http-methods/

GET - Retrieve a resource/Retrieve data from DB
	  search	  
POST - to send data to server  ( sign up ) 
       (create a resource/create a new record in DB)
	   to fetch data securly    (send params in body not in URL)
PUT - update data/create or replace a resource  
	  update user's profile information 	  
PATCH - update/modify a particular resource(partial update)
        update user password
DELETE - Remove a resource/delete a record from DB 
		 Delete naukri account
OPTIONS - information about the Permitted HTTP methods (methods/content type)
       Identifying which HTTP methods a resource supports, e.g. can we DELETE it or update it via a PUT?
HEAD - method returns info about resource (version/length/type)
	  similar to the GET method. But it doesn’t have any response body.




Route-Parameter
================
1. PathParam
-passed after /
 ex:- /productDetails/101
-Need to define in the route
 ex: app.get('users/:id')
-If defined than need to pass in url
-Used to pass 1 value

2. QueryParam
-passed after ?
  ex: /search?searchWord=skybag&filter=something
-No Need to define in the route
  ex: app.get('users')
-not complusory to pass
-used to pass multiple values.



Query String Module
===================
-Node.js Query String provides methods to deal with query string. 
-It can be used to convert query string into JSON object and vice-versa.
querystring.parse(str[, sep][, eq][, options])	queryString To object.
querystring.stringify(obj[, sep][, eq][, options]) object to string.




Node.js Streams
===============
-Streams are objects that let you read data from a source or write data to a destination in continuous fashion.
-four types of streams: 1.Readable  2.writeable  3.Duplex   4.Transform




Express.JS
==========
-Express.js is a web application framework for Node.js.
-a framework is a set of helper functions,tools and rules that help us to build our application.
-It provides various features that make web application development fast and easy which otherwise takes more time using only Node.js.
-Alternatives to Express.js are 'Vanilla Node.js','koa','sails.js'

Advantages of Express.js
========================
-Makes Node.js web application development fast and easy.
-Easy to configure and customize.
-Allows you to define routes of your application based on HTTP methods and URLs.
-Includes various middleware modules which you can use to perform additional tasks on request and response.
-Easy to integrate with different template engines like Jade, Vash, EJS etc.
-Allows you to define an error handling middleware.
-Easy to serve static files and resources of your application.
-Allows you to create REST API server.
-Easy to connect with databases such as MongoDB, Redis, MySQL


How to use Express
==================
1. import express
   const express = require('express')
2. create an instance of express.
   const app = express()
3. use methods
   app.get(route, callback)


Express Methods
===============
app.get()
app.post()
app.put()
app.patch()
app.delete()
app.listen()
app.use()
app.all()



app.use() vs app.get()
======================
-app.use() is generally used for introducing middlewares and can handle all type of HTTP requests.
-app.get() is only for handling GET HTTP requests.


app.use() vs app.all()
======================
app.use() → It takes only one callback.
app.all() → It can take multiple callbacks.

app.use() will only see whether url starts with specified path.
app.all() will match the complete path.

app.use( "/book" , middleware);
// will match /book
// will match /book/author
// will match /book/subject

app.all( "/book" , handler);
// will match /book
// won't match /book/author   
// won't match /book/subject    

app.all( "/book/*" , handler);
// won't match /book        
// will match /book/author
// will match /book/subject




Express Routers
===============
-Routing refers to how an application’s endpoints (URIs) respond to client requests.



Express.js Request Object Properties
====================================
req.app
req.body
req.cookies
req.hostname
req.ip
req.method
req.params
req.path
req.protocol
req.query



Response methods
================
The methods on the response object (res) in the following table can send a response to the client, and terminate the request-response cycle. If none of these methods are called from a route handler, the client request will be left hanging.

Method	Description
res.send()	Send a response of various types.
res.end()	End the response process.
res.json()	Send a JSON response.
res.jsonp()	Send a JSON response with JSONP support.
res.redirect()	Redirect a request.
res.render()	Render a view template.
res.sendFile()	Send a file as an octet stream.
res.download()	Prompt a file to be downloaded.
res.sendStatus()	Set the response status code and send its string representation as the response body.



Express generator
=================
1. npm install -g express-generator
2. express --view=ejs project1
   express project2 --no-view






Serving static files in Express
===============================
-To serve static files such as images, CSS files, and JavaScript files, use the express.static built-in middleware function in Express. 
express.static(root, [options])
-The root argument specifies the root directory from which to serve static assets.
 app.use(express.static('public'))
-To use multiple static assets directories, call the express.static middleware function multiple times:
	app.use(express.static('public'))
	app.use(express.static('files'))
	
	
Middlewares
===========
-Middlewares are like a middleman between a request and the response in a REQUEST → RESPONSE cycle.
-Middlewares in ExpressJS are just functions that can modify these Request and Response objects either to retrieve or store relevant information.
-An example of a simple express js middleware could be to log the current date and time on every URL the user visits on our website.

req => middleware => res

app.use((req, res, next) => {
  console.log('The time is: '+ Date.now())
  next();
})


Order of Middleware Calls
=========================
-The order in which they are written/included in your file; the order in which they are executed.
 


Body-parser
===========
-parse the body of requests which have payloads attached to them.
-Parse incoming request bodies in a middleware before handlers are invoked.
-extracts the body portion of an incoming request & exposes it on req.body.
-parses the data submitted using HTTP POST request.
 npm install body-parser --save


cookie-parser
=============
-It parses Cookie header and populate req.cookies with an object keyed by cookie names. 
	var cookieParser = require('cookie-parser');
	app.use(cookieParser())



CORS
====
-Cross Origin Resource Sharing or CORS is a technique to tell the browser whether a application can fetch resources from a different domain or not.
-By default, browsers will block certain requests if both the client and the server are not in the same origin.

-CORS is a node.js package.
-How to Install
 npm install cors

Default Configuration 
{
  "origin": "*",
  "methods": "GET,HEAD,PUT,PATCH,POST,DELETE",
  "preflightContinue": false,
  "optionsSuccessStatus": 204
}
https://www.npmjs.com/package/cors




Events
======
-Node.js allows us to create and handle custom events easily by using events module.
-Event module includes EventEmitter class which can be used to raise and handle custom events.
-The emit() function raises the specified event. First parameter is name of the event as a string and then arguments.
-An event can be emitted with zero or more arguments. 
-We can specify any name for a custom event in the emit() function.
-We can also use addListener() methods to subscribe for an event.
-All objects that emit events are instances of the EventEmitter class. 
-These objects expose an eventEmitter.on() function that allows one or more functions  to be attached to named events emitted by the object. 
-Event names are camel-cased strings but any valid JavaScript property key can be used.
-When the EventEmitter object emits an event, all of the functions attached to that specific event are called synchronously. 
-Any values returned by the called listeners are ignored and will be discarded.
-The eventEmitter.on() method is used to register listeners, 
-eventEmitter.emit() method is used to trigger the event.
-The EventEmitter calls all listeners synchronously in the order in which they were registered.
-This ensures the proper sequencing of events and helps avoid race conditions and logic errors. 
When appropriate, listener functions can switch to an asynchronous mode of operation using the setImmediate() or process.nextTick() methods:
-Using the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. 
-Once the event is emitted, the listener is unregistered and then called.

 
EventEmitter Properties and Methods
------------------------------------
addListener()-			Adds the specified listener
defaultMaxListeners-	Sets the maximum number of listeners allowed for one event. Default is 10
emit()					Call all the listeners registered with the specified name
eventNames()			Returns an array containing all registered events
getMaxListeners()		Returns the maximum number of listeners allowed for one event
listenerCount()			Returns the number of listeners with the specified name
listeners()				Returns an array of listeners with the specified name
on()					Adds the specified listener
once()					Adds the specified listener once. When the specified listener has been executed, the listener is removed
prependListener()		Adds the specified listener as the first event with the specified name
prependOnceListener()	Adds the specified listener as the first event with the specified name, once. When the specified listener has been executed, the listener is removed
removeAllListeners()	Removes all listeners with the specified name, or ALL listeners if no name is specified
removeListener()		Removes the specified listener with the specified name
setMaxListeners()		Sets the maximum number of listeners allowed for one event. Default is 10




Template Engines for Node.js
============================
-Template engine helps us to create an HTML template with minimal code. 
-It can inject data into HTML template at client side and produce the final HTML.
-template engines for Node.js (Jade/pug,Vash,EJS,Handlebars)




Data Access in Node.js
======================
-Node.js supports all kinds of databases(RDBMS/NO-SQl).However, NoSQL databases like MongoDB are the best fit with Node.js
-To access the database from Node.js, the driver needs to be installed for the database 
ex:npm install mysql (for MySQL)
   npm install oracledb (for Oracle)
   npm install mongodb (MongoDB)


MongoDB
=======
-it stores data in the collections as JSON based documents and does not enforce schemas. 
-UnStructured data.
-It does not have tables, rows, and columns as other SQL (RDBMS) databases.
-RDBMS  (Database,Table,Row,Column)
 MongoDB(Database,Collection,Document,Field)
-indexing , shemaless , Replication, Scalability, Performance, High Availability.
-No SQL databases - cassandra, Amazon Dynamo DB, couchbase, redis.

Sql         NoSql
===================
Database    Database
Table       Collection
Row         Document
Column		Field
Select      find
Insert      Insert
Update      Update
Delete      Remove

schema- predefined  schema-run time
join                no join



MongoDB Local
=============
1. download and install (MongoDB Community Server)
   https://www.mongodb.com/try/download/community 
2. Go to the path where MongoDB is installed,and run mongo.exe  
   By default it is "C:\Program Files\MongoDB\Server\5.0\bin"
4. Expect Error as the data directory is not set
   "{"error":"NonExistentPath: Data directory C:\\data\\db\\ not found"
5. create folder 'c:\data\db'
6. run mongo.exe


MongoDB Shell (CLI for mongoDB)
=============
-download mongoDB shell 
 https://www.mongodb.com/try/download/shell
-extract and run mongosh.exe
-set path for mongo-server  & mongo-shell
	 C:\Program Files\MongoDB\Server\6.0\bin
	 C:\mongo-shell\bin	    
-verify the path setup is done correctly by running below 2 commands
 mongod --version
 mongosh -version 
-Start Mongo Shell 
 start mongosh.exe 
-Enter mongoDB Connection String 
 mongodb://localhost:27017
 
 
MongoDB Compass
===============
-MongoDB Compass is a graphical interface to interact with the MongoDB 
1. download and install mongoDB Compass
  https://www.mongodb.com/products/compass
2. open mongoDB Compass GUI
3. Enter mongoDB Connection String 
   mongodb://localhost:27017  (OR)
   mongodb://127.0.0.1:27017

 
Note: If mongoDB and mongoShell are installed & path is set
-open 2 command prompts
-run 'mongod' in 1st cmd
-run mongosh in 2nd cmd
 

 
MongoDB Queries/Commands
========================= 
https://www.geeksforgeeks.org/mongodb-tutorial/

-To See All databases
 show dbs
-To Use one database
 use sanjaydb1  (creates a new database if it doesn’t exist)
-To see the Current Database
 db 
-To see all the collections under a database
 show collections
-To Create a Collection/Table
 db.createCollection('employees')
-To add a Document/Row in a collection
 db.employees.insertOne({eid:1,name:'sanjay',sal:5000})
 db.employees.insertOne({_id:1,name:'sanjay',sal:5000})
 db.employees.insertOne({_id:2,name:'sanjay 2',sal:5000})
 db.employees.insertMany([{eid:1,name:'sanjay',sal:5000},
            {eid:2,name:'ranjan',sal:6000}])
-To  see data inside collections
 db.employees.find() // db.employees.findOne()
 db.employees.find().pretty()
 db.employees.find( {sal: 6000} )
 db.employees.find( {name:'abc',sal: 6000} )
 db.employees.find({sal: {$lt:6000}}) 
 db.employees.find({sal: {$lte:6000}}) 
 db.employees.find({sal: {$ne:6000}})
 db.employees.find({sal: {$gt:5000, $lt:9000}})
 db.employees.find({"name":{$in:["Raj", "Ram", "Raghu"]}})
 db.employees.find({"name":/sanjay/i})   // (Like in SQL)
 db.employees.find( {} , {sal:0} ) // all columns except sal
 db.employees.find( {} , {sal:1,name:1} ) // name,sal column in result
 db.employees.find().sort({sal:1}).pretty()   //asc
 db.employees.find().sort({sal:-1}).pretty() //desc
 db.employees.find().count()
 db.employees.find().limit(2)
-To Update the existing Data
 db.employees.updateOne( { id: 101 }, { $set: { sal: 2000 } } ) 
 db.employees.updateOne( { id: 101 }, {eid:1,name:'sanjay',sal:5000},{ upsert: true } )
 // Update the document, but if not found insert it
-To Delete 
 db.employees.deleteOne({ id:101 })
 db.employees.deleteMany({ name: "sanjay" })
 db.employees.remove({ id:101 }) 	// Deprecated
 db.employees.remove({ id:101 }, 1)
 db.employees.remove({})   // Remove All Documents(equivalent of SQL's truncate)
 
 db.employees.drop()
 db.dropDatabase() 
 
 
Managing Indexes
================
-Without indexes, MongoDB must scan every document of a collection to select those documents that match the query statement. 
-This scan is highly inefficient and require MongoDB to process a large volume of data.
-Indexes are special data structures, that store a small portion of the data set in an easy-to-traverse form. 
-The index stores the value of a specific field or set of fields, ordered by the value of the field as specified in the index.
-Avoids Collection Scan, Effective Indexing Strategy, Search Efficiency.


-Create an index (db.COLLECTION_NAME.createIndex({KEY:1}))
 db.user.createIndex({"name.family": 1})
 db.user.createIndex({email: 1}, {unique: true})  
 //at most one record in the collection with a given value for that field
-See indexes on a collection
 db.user.getIndexes()
-Drop an index
 db.user.dropIndex("email")
 db.user.dropIndexes()
 


Assignment
==========
1. Find distinct salaries in asccending order and store in a variable.
2. Find the 3rd highest salary in the table.
3. Find the employees whose DOB is today's date.
4. increase the salary of every employee by 500.
5. change the 'gender' of every employee (male-->female,female-->male)




MongoDB Atlas
=============
-MongoDB Atlas is a fully-managed cloud database.

-Register for an Atlas account
 https://www.mongodb.com/atlas/database (click on try Free)
-Create and deploy an M0 cluster
-Add your connection IP address to your IP access list
-Create a database user for your cluster
-Connect to your cluster
-Load sample data or your own data!
https://www.javatpoint.com/mongodb-atlas

mongodb+srv://sanjaysamantra:<password>@cluster0.geshq.mongodb.net/?retryWrites=true&w=majority



ORM - Object Relational Model
=============================
-The benefit of using an ORM is that programmers can continue to think in terms of JavaScript objects rather than database semantics.
-There are many ODM/ORM solutions available-Mongoose, Sequelize, GraphQL

Mongoose
========
-Mongoose is a MongoDB object modeling tool.
https://mongoosejs.com/docs/guide.html


GraphQL
=======
-GraphQL is a query language for APIs.
-GraphQL provides a complete and understandable description of the data in API.
-It gives clients the power to ask for exactly what they need and nothing more.
-Advantages of GraphQL:- declarative, compositional, strongly-typed




Redis
=====
-Redis Stands for 'Remote Dictionary Server'.
-fast, open source, in-memory, key-value data store.
-used as a database, cache, message broker.
-Redis speed makes it ideal for caching database queries, complex computations, API calls, and session state.
-The stream data type enables high-rate data ingestion, messaging, event sourcing, and notifications.
-Redis Cann't replace DB,it can only (set,get,delete)


How To Install Redis
====================
1. https://github.com/microsoftarchive/redis/releases
2. download Redis-x64-3.0.504.msi  and install
3. add redis as path variable
   C:\Program Files\Redis
4. open CMD-->redis-cli 
   127.0.0.1:6379  
5. check redis version
   redis-server -v


Commands
========
-To check the existing Data
 KEYS *
-Set Data (Syntax: set key value expiryTime)
 SET name sanjay
 SET add bangalore ex 2000 
 SETEX age 3600 45
-Get Data (get keyName)
 get name 
 get add
 get Add  (nil) (Keys are case sensitive)
-Delete Data (delete keyName)
 del name
-Delete all 
 FLUSHALL
-Check if a key exists (1-Yes,0-No)
 EXISTS keyName
-Rename key
 RENAME name fName
-Check Data type of the value
 TYPE keyName
-INFO (to check redis server details)




Fake APIs to fetch data
=======================
https://api.openweathermap.org/data/2.5/forecast/daily?q=bangalore&mode=json&units=metric&cnt=5&appid=fbf712a5a83d7305c3cda4ca8fe7ef29

https://en.wikipedia.org/w/api.php?action=parse&format=json&section=0&page=india

https://dummyjson.com/docs/products




ESLint
======
1. npm i eslint -g
2. npm init @eslint/config   
         (OR) 
   npx eslint --init
3. eslint .




Nodemailer
==========
1. npm install nodemailer 

password
========
Go to your Google Account.(https://myaccount.google.com/)
Select Security.
Under "Signing in to Google," select App Passwords. You may need to sign in. If you don’t have this option, it might be because:
2-Step Verification is not set up for your account.
2-Step Verification is only set up for security keys.
Your account is through work, school, or other organization.
You turned on Advanced Protection.
At the bottom, choose Select app and choose the app you using and then Select device and choose the device you’re using and then Generate.
Follow the instructions to enter the App Password. The App Password is the 16-character code in the yellow bar on your device.
Tap Done.




Socket IO / Chat Application
=============================
-"socket.io": "^2.2.0"





Swagger
=======
-It’s very important to write documentation for APIs so that whoever consumes those APIs understand them, implement them, and play around with them.
-Swagger is a software tool used for designing, building, documenting, and using RESTful APIs.
-Swagger simplifies API development for users, teams, and enterprises with the Swagger open source and professional toolset.
-We can define all the operations in the file swagger.json
-We can have your custom CSS for your swagger page.







JSON Web Token
==============
-JSON Web Token (JWT) is a standard that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.
-used for authentication. After a user signs in to an application, the application then assigns JWT to that user. Subsequent requests by the user will include the assigned JWT. This token tells the server what routes, services, and resources the user is allowed to access.
-A JSON Web Token consists of: 1.Header  2.Payload  3.signature

https://www.section.io/engineering-education/how-to-build-authentication-api-with-jwt-token-in-nodejs/

1. npm init -y
2. npm install mongoose express dotenv cors body-parser jsonwebtoken bcryptjs
3. 





Unit Testing with Jasmine
=========================
-Unit testing is important to verify the behavior of the smallest units of code in application. 
-It helps improve the quality of  code and reduces the amount of time we spend on bug fixing. 
-unit testing helps to find bugs early on in the development life cycle.
-Jasmine is an open-source and  popular JavaScript library testing framework to test any kind of JavaScript application.


1.install jasmine globally
   npm i -g jasmine
2.Install jasmine-node
   npm install jasmine-node
3.Initialize the Jasmine Environment
  jasmine init
4.verify your configuration file. (spec/support/jasmine.json)
  jasmine.json
5.run the below command to run tests
  jasmine
 
 
Jasmine Terminologies
=====================
describe()  Test suite (Group of testcases)
it() 		test case / spec

expect(actual).matcher(expected);
expect(app.add(2,3)).toBe(5);


Matchers
--------
toBe();
not.toBe();
toBeDefined();
not.toBeDefined();
toEqual();
toBeTruthy();  
toBeFalsy();  
toBeGreaterThan();
toBeLessThan();
toContain()


Jasmine Global Functions
------------------------
beforeAll()
beforeEach()
afterEach()
afterAll()

fdescribe() - focused describe. If it exists, jasmine will run only fdescribe spec and ignore other type of describe (describe and xdescribe).
xdescribe() - disabled describe. It will never be executed.
fit() - focused it()
xit() - disabled it()



Unit testing with Mocha & Chai
==============================
-Mocha is a testing framework for NodeJS.
-Chai is an assertion library

global install
	npm install mocha -g
project install
	npm i -D mocha chai chai-http
	

Chai Assertion Style
--------------------
1. should 
	ex: abc.should.have.lengthOf(3)
2. expect
   ex: expect(foo).to.have.lengthOf(3)
3. assert
   ex: assert.lengthOf(foo,3)





References:
===========
1. https://riptutorial.com/Download/node-js.pdf
2. https://nodejs.dev/en/learn/
3. https://www.tutorialsteacher.com/nodejs
4. https://www.javatpoint.com/nodejs-tutorial
5. https://www.guru99.com/node-js-tutorial.html
6. https://codeforgeek.com/nodejs/
7. https://www.geeksforgeeks.org/nodejs/
8. https://training-course-material.com/training/Nodejs



Interview Questions & Answers
=============================
1.https://gist.github.com/paulfranco/9f88a2879b7b7d88de5d1921aef2093b
2.https://github.com/Devinterview-io/nodejs-interview-questions


---------------------------
md5 generator
express file uploader
express-validator
formidable - https://www.w3schools.com/nodejs/nodejs_uploadfiles.asp
loadtest npm package
---------------------------------------
Asked Questions

1- update() findOneAndUpdate()
2- drop & remove()
3- createIndex() & reIndex()
   builds an index on a collection
   rebuild all existing indexs on a collection
4- How to get system info on which mongoDB is running
	db.hostInfo()
5- How to remove the current database ?
	db.dropDatabse
6- How to rename a collection?
	db.collection.renameCollection()
7 - findModify() findOneAndUpdate()
	findModify - atomically modifies and return a single document
	findOneAndUpdate - Find a single document and upd
